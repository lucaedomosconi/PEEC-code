% clearvars
% close all
omega = 2 * pi * freq;
skindepth = sqrt(2/omega/mu/sigma);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% mesh construction                                                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



[Y,X] = meshgrid(linspace(-b/2,b/2,n+1), linspace(-a/2,a/2,m+1));
if mod_mesh
  [Y,X] = meshgrid(b/2*sin(linspace(-pi/2,pi/2,n+1)),a/2*sin(linspace(-pi/2,pi/2,m+1)));
endif
%Z = zeros(size(X));
Z = 0. * (X.^2 - Y.^2); % plane
if semicilinder
Z = a/2 - sqrt(a^2/4-X.^2) + 0.* Y;
endif
GG = tanh((1+1i)*thickness/2/skindepth)/((1+1i)*thickness/2/skindepth);
if !G_form
  GG = 1.;
endif

% preparing data input
str_freq = [[folder_str_prefix freq_str(freq_id,:) "/bx_real.txt"];...
[folder_str_prefix freq_str(freq_id,:) "/by_real.txt"];...
[folder_str_prefix freq_str(freq_id,:) "/bz_real.txt"];...
[folder_str_prefix freq_str(freq_id,:) "/bx_imag.txt"];...
[folder_str_prefix freq_str(freq_id,:) "/by_imag.txt"];...
[folder_str_prefix freq_str(freq_id,:) "/bz_imag.txt"]];
titles = ["Bx real"; "By real"; "Bz real";"Bx imag"; "By imag"; "Bz imag"];

if (!exist('postprocess') || !postprocess)

pkg load parallel
np = 4;
if mod(n*m,np)
  frptintf("Error!\nn*m must be divisible by np\n")
endif
% nodes matrix: (size 3 x num_nodes)
nodes = [X(:)'; Y(:)'; Z(:)'];

% connectivity matrix: (size 3 x num_elements)
cnc = [1,   m+3;
       2,   m+2;
       m+3, 1];
cnc = repmat(cnc, 1, m);
cnc += kron([0:m-1], [1,1]);
cnc = repmat(cnc, 1, n);
cnc += kron([0:m+1:m*n], ones(3,m*2));
if plot_options(1)
  figure
  trimesh(cnc', nodes(1,:), nodes(2,:), nodes(3,:));
  axis equal
endif

midpoint = squeeze(sum(reshape(nodes(:,cnc), 3,3,[]), 2))/3;

num_elements = size(cnc, 2);
num_nodes = size(nodes, 2);

X1 = nodes(:, cnc(1, :));
X2 = nodes(:, cnc(2, :));
X3 = nodes(:, cnc(3, :));
Area = 0.5 * norm(cross(X2-X1, X3-X1, 1), 2, 'cols');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% matrix and rhs assembly                                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A0_func = @(x) [0.5 * (B0y * x(3,:) - B0z * x(2,:)); ...
                0.5 * (B0z * x(1,:) - B0x * x(3,:)); ...
                0.5 * (B0x * x(2,:) - B0y * x(1,:))];
A0 = A0_func(midpoint);
Bext = [B0x,B0y,B0z]'.*ones(3,num_elements);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% A0 generated by a square wire                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if spire_generated_field
% Bz(0,0,0) = 2*sqrt(2)*mu0*I/pi/L when h = 0
  I_ = 1.;
  L_ = 0.025; h_ = 0.05;
%  I_ = pi*L_/mu0/2^1.5;
%  L_ = 0.4;
%  h_ = 0.05;
  A0_func = @(x) [solvePotential(x,I_,L_,h_,1);
                  solvePotential(x,I_,L_,h_,2);
                  solvePotential(x,I_,L_,h_,3)];
                  A0 = A0_func(midpoint);
% can improve only if plate
%  A0_upper = A0_func(midpoint+[0.;0.;thickness/2]);
%  A0_lower = A0_func(midpoint-[0.;0.;thickness/2]);
%  A0 = (A0_upper+A0_lower)/2;
  B0_func = @(x) [solveBField(x,I_,L_,h_,1);
                  solveBField(x,I_,L_,h_,2);
                  solveBField(x,I_,L_,h_,3)];
  B0 = B0_func(midpoint);
  Bext = B0;
endif

Curlw = nan(3, num_elements, 3);
for ii = 1:num_elements
  for mm = 1:3
    Curlw(:, ii, mm) = curlw(mm, X1(:, ii), X2(:, ii), X3(:, ii));
  end
end

M = zeros(num_nodes);
rhs = zeros(num_nodes, 1);

fprintf('Matrix assembly\n')
tic

for ii = 1:num_elements

  [gpi, gwi] = tri_gauss_points(3, X1(:, ii), X2(:, ii), X3(:, ii));
  gpi = squeeze(gpi);
  gwi = squeeze(gwi);

  % resistance matrix
  %
  %                      /  ->         ->
  % R = 1/(GG . sigma) * | CurlT(x) . CurlT'(x) dx
  %                      /
  %                      S
  
  for mm = 1:3
    for nn = 1:3
      M(cnc(mm, ii), cnc(nn, ii)) += Curlw(:,ii,nn).' * Curlw(:,ii,mm) * Area(ii) / sigma / GG;
    end
  end

  % inductance matrix
  %
  %                                 / /   ->         ->
  % L = (mu0 * thickness)/(4*pi) *  | | (CurlT(x) . CurlT'(y)) / |x - y| dxdy
  %                                 / /
  %                                 S S
  G = zeros(numel(gwi), num_elements);
  for kk = 1:numel(gwi)
    G(kk,:) = int_Gconst_tri_mesh(nodes, cnc, gpi(:,kk));
  end
  for mm = 1:3
    for nn = 1:3
      MM = (gwi.' * G) .* ((Curlw(:,ii,mm).' * Curlw(:,:,nn))) ...
         * thickness * 1i * omega * mu0 / (4 * pi);
      M(cnc(mm, ii), :) += accumarray(cnc(nn,:).', MM, [1,num_nodes]);
    end
  end % M = R + 1i * omega * L

  % right-hand side
  %
  %                     /  ->       ->
  % rhs = -1i * omega * | A0(x) . CurlT(x) dx
  %                     /
  %                     S
  for mm = 1:3
    rhs(cnc(mm, ii)) += -1i * omega * Curlw(:,ii,mm).' * A0(:, ii) * Area(ii);
  end

end
toc
fprintf('\n')

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% homogeneous dirichlet boundary conditions on T                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

idx_left  = [1: (m+1): (m+1)*(n+1)];
idx_right = [m+1: (m+1): (m+1)*(n+1)];
idx_lower = [1: 1: (m+1)];
idx_upper = [(m+1)*n+1: 1: (m+1)*(n+1)];
idx_boundary = [idx_lower, idx_upper, idx_left, idx_right];
M(idx_boundary,:) = 0;
for ii = idx_boundary
  M(ii, ii) = 1;
end
rhs(idx_boundary) = 0;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% linear system solution                                                       %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% diagonal preconditioner
Pinv = 1./ diag(M);
M = Pinv .* M;
rhs = Pinv .* rhs;

T = M \ rhs;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% post-processing and plots                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

J = zeros(3, num_elements);
for ii = 1:num_elements
  for mm = 1:3
    J(:,ii) += T(cnc(mm, ii))*Curlw(:,ii,mm);
  end
end
Js = J*thickness;
Btot = zeros(3,num_elements);
if compute_auto_induced_B
  prec_in_small_tria = 4;
  prec_in_near_tria = 5;
  prec_in_far_tria = 1;
  distance_near = 0.004;
  fprintf("start computation of Btotal\n");
  for bar = 1:num_elements/20
    fprintf("_");
  end
  fprintf("\n");
  elem_index_vector = 1:num_elements;
  par_fun = @(id_pr) parallel_losses(id_pr,np,prec_in_small_tria,...
            distance_near,prec_in_near_tria,prec_in_far_tria,...
            midpoint,num_elements,Js,X1,X2,X3);
  Btot = parcellfun(np,par_fun,{0,1,2,3});
  Btot = [Btot{1,1};Btot{1,2};Btot{1,3};Btot{1,4}];
  Btot = Btot';
  Btot = Btot.*(GG*mu0/4/pi);
endif
fprintf('\n')
Btot += Bext;
Bort = (dot(cross(X2-X1,X3-X1),Btot)./((norm(cross(X2-X1,X3-X1),'cols')).^2)) .* cross(X2-X1,X3-X1);
Bm = Btot - Bort;
%Bm = Bort; %if want to compute the real Bort decoment section in parallel_losses.m

losses = 0.5*real(dot(J,J,1)/GG/sigma - 1i*omega*dot(Bm,Bm)/GG/mu0);
losses_tot = thickness*dot(losses,Area);
%{
losses = 0.5 * dot(J,J,1) / sigma / GG;
losses_tot = losses * Area.' * thickness;
%}

%losses = 0.5 * dot(J,J,1) / sigma / GG;
%losses_tot = losses * Area.' * thickness
fprintf('Joule losses = %e W', losses_tot)

Jabs_real = norm(real(J), 2, 'cols');
Jabs_imag = norm(imag(J), 2, 'cols');


endif %% postprocess start


if plot_options(5)
  fprintf("\ncomputing B on line:\n")
  h = 0.01;
  y = 0.00;
  include_external_field = 1;
  line_extention = 6*a;
  line_subdivisions = 200;
  for bar = 1:line_subdivisions/5
    fprintf('_')
  end
  fprintf("\n")
  x_line = [linspace(-line_extention/2,line_extention/2,line_subdivisions);ones(2,line_subdivisions).*[y;h]];
  par_fun_line = @(id_pr) LineBcompute(id_pr,np,x_line,X1,X2,X3,Js);
  BtotLine = parcellfun(np,par_fun_line,{0,1,2,3});
  BtotLine = [BtotLine{1,1};BtotLine{1,2};BtotLine{1,3};BtotLine{1,4}];
  BtotLine = BtotLine';
  BtotLine *= (mu0/4/pi);
  if (!spire_generated_field && include_external_field)
    BtotLine += [B0x;B0y;B0z];
  endif
  if (spire_generated_field && include_external_field)
    BtotLine += B0_func(x_line);
  endif
endif

fprintf("\n");